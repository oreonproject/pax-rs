# Hello, brave soul! ðŸ‘‹

This is arguably the most complicated part of PAX, so don't worry if the code here is too difficult for you to wrap your head around. Actually, you are in luck - all the modules you see here were once in one **large** `lib.rs` file, so now that they have all been containerized I hope this library is easier to follow. If it's not, that's totally OK - after all that's what I'm here for! First I'll give an overview on the different modules and the structure of this library, and then get on to the important part - which bits of code you will need to touch to add your own package parser to Pax!

# Overview
## Depend Kind
This module holds the Dependency type enum - Latest, Specific, and Volatile.
### Latest
Sometimes, you don't care what version of a package is installed - you just want it _there_. Using the DependKind of Latest means you just need to specify the package name, and Pax will install it if it isn't already. Notice how its `DepVer.Range`'s bounds are both NoBound - this is the most relaxed Version Requirement, as it just confirms that the package is installed, whilst being careful not to mess with the fine-tuned dependency requirements of other packages. However, all good things come with a price - as any version is allowed for `Latest`, it is possible that an installed version of the dependency does not have the feature your package requires, meaning that this could cause headaches down the line. ...So that's where `Specific` comes into play!
### Specific
Usually, you will need to fine-tune which versions of the dependency to ensure that the installed version has the features that your package requires. Specific is therefore the most common type of DependKind for any given dependency. One obvious issue with `Specific` is how many bounds you can declare - the Pax format only allows ONE VERSION REQUIREMENT PER DEPENDENCY, which means that if you need dependency X version 1.2.3 or higher BUT ALSO lower than version 2.4.5, you sadly can't do that. ...Or can you? Pax has a Smart Dependency Resolution feature for aiding the installation of a package that has different requirements across different dependent packages. When Pax detects that a dependency is used TWO OR MORE TIMES, it collects every version requirement referencing said dependency, and attempts to negotiate a mutually-agreed-upon version to be installed. What this means is that if you declare the dependency TWICE in your package, once as Greater Than or Equal To 1.2.3, and the other as Less Than 2.4.5, Pax will automatically find the **latest suitable version of the dependency, and install it on your system**. Neat! But what do you do if you require a binary that may come pre installed on your computer?
### Volatile
By default, Pax looks in the `/etc/pax/installed` directory to determine if a package is installed. However, as binaries like `ssh` and `systemctl` usually come pre-installed with the OS, Pax will not have an `InstalledMetaData` file on the binary, and thus will have no idea how to update etc. the binary. So if your package requires one of these possibly-installed binaries, this is where you will use the `Volatile` DependKind. How this one works is pax runs `/usr/bin/which` against the specified dependency's name, and queries whether `which` was able to locate it. If `which` found it, the dependency is considered "met", and Pax will do nothing further with it, accepting that it is already installed. However, if `which` _fails_ to locate the binary, Pax will fallback to try and install it itself, ensuring that the dependency requirement is met before proceeding with the dependent's installation.
## Installed MetaData
Once a package has been installed, Pax must retain some information about the package to ensure Pax can safely update the package to the newest version, if and when available. Among the information stored, Pax will retain the lists of the `DepKind`s of the package dependencies - and not the literal installed version of the installed package. This was done so to allow new packages to depend on already-installed dependencies, while ensuring the installed version of the dependency is valid for all of its dependents. Another field to note is the `installed_kind`. This holds the different methods of uninstalling a package, so Pax knows how to manipulate the filesystem to safely remove packages when requested by the user, or when they simply are not required anymore. Currently there are only two supported types: PreBuilt and Compilable.
### PreBuilt
The `.deb` package system is actually an archive with files, stored in folders made to mimic the typical structure of the Linux filesystem, meaning that installing a `.deb` archive really means moving the specified files to predetermined locations. As such, Pax will remember which files it had placed where, so that when the package needs to be removed, Pax can re-walk the filesystem-structure, and remove all the installed files.
### Compilable
The `.rpm` package system is an archive of source code, with some build scripts and build instructions. As Pax therefore has no sane method of determining which files have been installed by the package, the filesystem-walking method used above won't work here, and thus Pax requires a different approach: An uninstall script. When a package is installed, it contains an uninstall script, which Pax retains for uninstallation, therefore allowing both these two distinct package installation techniques to work together.