# Overview
## Hello, brave soul! ðŸ‘‹
This is arguably the most complicated part of PAX, so don't worry if the code here is too difficult for you to wrap your head around. Actually, you are in luck - all the modules you see here were once in one **large** `lib.rs` file, so now that they have all been containerized I hope this library is easier to follow. If it's not, that's totally OK - after all that's what I'm here for! First I'll give an overview on the different modules and the structure of this library, and then get on to the important part - which bits of code you will need to touch to add your own package parser to Pax!
## Processed MetaData
Before a package is to be installed, Pax will need to convert the package metadata into a format that it understands - `ProcessedMetaData`. This universal format allows for Pax's most powerful feature - the ability to easily integrate alternate package managers' ecosystems into Pax. Note that this format is only use temporarily, as when a package is installed, Pax will convert it into `InstalledMetaData`
## Installed MetaData
Once a package has been installed, Pax must retain some information about the package to ensure Pax can safely update the package to the newest version, if and when available. Among the information stored, Pax will retain the lists of the `DepKind`s of the package dependencies - and not the literal installed version of the installed package. This was done so to allow new packages to depend on already-installed dependencies, while ensuring the installed version of the dependency is valid for all of its dependents. Another field to note is the `installed_kind`. This holds the different methods of uninstalling a package, so Pax knows how to manipulate the filesystem to safely remove packages when requested by the user, or when they simply are not required anymore. Currently there are only two supported types: PreBuilt and Compilable.
### PreBuilt
The `.deb` package system is actually an archive with files, stored in folders made to mimic the typical structure of the Linux filesystem, meaning that installing a `.deb` archive really means moving the specified files to predetermined locations. As such, Pax will remember which files it had placed where, so that when the package needs to be removed, Pax can re-walk the filesystem-structure, and remove all the installed files.
### Compilable
The `.rpm` package system is an archive of source code, with some build scripts and build instructions. As Pax therefore has no sane method of determining which files have been installed by the package, the filesystem-walking method used above won't work here, and thus Pax requires a different approach: An uninstall script. When a package is installed, it contains an uninstall script, which Pax retains for uninstallation, therefore allowing both these two distinct package installation techniques to work together.
## Depend Kind
WHen acquiring the dependencies of a package, Pax will have to determine which method to use to find a specified dependency, as different dependency types have different acquisition techniques. To allow pax to do this, every dependency is categorized into one of three types - Latest, Specific, and Volatile.
### Latest
Sometimes, you don't care what version of a package is installed - you just want it _there_. Using the DependKind of Latest means you just need to specify the package name, and Pax will install it if it isn't already. Notice how its `DepVer`'s `Range`'s bounds are both `NoBound` - this is the most relaxed Version Requirement, as it just confirms that the package is installed, whilst being careful not to mess with the fine-tuned dependency requirements of other packages. However, all good things come with a price - as any version is allowed for `Latest`, it is possible that an installed version of the dependency does not have the feature your package requires, meaning that this could cause headaches down the line. ...So that's where `Specific` comes into play!
### Specific
Usually, you will need to fine-tune which versions of the dependency to ensure that the installed version has the features that your package requires. Specific is therefore the most common type of DependKind for any given dependency. One obvious issue with `Specific` is how many bounds you can declare - the Pax format only allows ONE VERSION REQUIREMENT PER DEPENDENCY, which means that if you need dependency X version 1.2.3 or higher BUT ALSO lower than version 2.4.5, you sadly can't do that. ...Or can you? Pax has a Smart Dependency Resolution feature for aiding the installation of a package that has different requirements across different dependent packages. When Pax detects that a dependency is used TWO OR MORE TIMES, it collects every version requirement referencing said dependency, and attempts to negotiate a mutually-agreed-upon version to be installed. What this means is that if you declare the dependency TWICE in your package, once as Greater Than or Equal To 1.2.3, and the other as Less Than 2.4.5, Pax will automatically find the **latest suitable version of the dependency, and install it on your system**. Neat! But what do you do if you require a binary that may come pre installed on your computer?
### Volatile
By default, Pax looks in the `/etc/pax/installed` directory to determine if a package is installed. However, as binaries like `ssh` and `systemctl` usually come pre-installed with the OS, Pax will not have an `InstalledMetaData` file on the binary, and thus will have no idea how to update etc. the binary. So if your package requires one of these possibly-installed binaries, this is where you will use the `Volatile` DependKind. How this one works is pax runs `/usr/bin/which` against the specified dependency's name, and queries whether `which` was able to locate it. If `which` found it, the dependency is considered "met", and Pax will do nothing further with it, accepting that it is already installed. However, if `which` _fails_ to locate the binary, Pax will fallback to try and install it itself, ensuring that the dependency requirement is met before proceeding with the dependent's installation.

# Porting to Pax
Now that you understand a little bit on how Pax parses packages, it's time to port a package type to pax! Each subchapter below cover a specific file/folder you will need to modify to ensure your port is fully integrated into Pax.
## `/settings/src/lib.rs`
(Relax, this is the only file you will need to modify _outside_ this metadata directory.)
To ensure Pax will use the correct parsing method for your package type, you need to specify a new type in `OriginKind`. Usually the origin type takes in a string. (GitHub note: currently only Pax packages will be supported through GitHub. This feature is experimental, and thus may change sometime in the future, or be outright removed.)
## `src/parsers/mod.rs`
Add your package type as an **EMPTY**, type to `MetaDataKind`.
## `src/parsers/{name}/mod.rs`
Here you will implement the `Raw{name}` struct for your package's data. If you plan on following `RawPax`'s implementation technique, the struct will require `#[derive(Deserialize)]` to be able to be pulled from the web. while the struct itself must be public, the individual fields may be private. Your parser will also require an `impl` of `pub fn(self, ...) -> Option<ProcessedMetaData>` or similar to be able to be converted to the `ProcessedMetaData` type. It is essential that the function can output **only a single instance of** `ProcessedMetaData`, with the `kind` value set to the `MetaDataKind::{name}` as you implemented above. Do not worry for the `dependent` field, it will be set by the caller later. `RawPax` just sets this to `true`. The returned `ProcessedMetaData` may optionally be wrapped in `Option<>`, but not `Result<>`. Now go back to `src/parsers/mod.rs`, and add `pub mod {name};`. Note that is must be a public import, otherwise you will struggle with issues later in `src/lib.rs`.
## `src/processed/mod.rs`
In the `use crate::{...}` section, add `{name}::Raw{name}`. Then in the `impl` of `ProcessedMetaData`, go to `async fn get_metadata(...) -> Option<Self>`, specifically to the `match source`, which your LSP should be screaming is erroneous as it is non-exhaustive. Add a branch for `OriginKind::{name}`, and implement the acquisition of the metadata. You could use a method like shown with `OriginKind::Pax` where `serde` creates the struct from some pulled data, OR you could slightly modify the function you made above to take in the raw pulled text from the specified endpoint. Or whatever you like - Pax isn't too picky, as long as you return the value correctly.
## `src/lib.rs`
At the top, locate the `use crate::{...}` section, and add `{name}` to the `parsers::{...}` segment. If you get an error here, make sure you did a `pub mod` in `src/parsers/mod.rs`. Then... you're done! Really, truly! Wasn't that so simple (famous last words)...